#+title: Function Domain Driven Design with Kotlin
#+author: Michael Sperber & Benedikt Stemmildt
#+REVEAL_PLUGINS: (notes)
#+REVEAL_THEME: ./css/themes/active.css
#+REVEAL_HLEVEL: 100
#+REVEAL_TRANS: none
#+OPTIONS: num:nil toc:nil reveal-center:f reveal_slide_number:t reveal_title_slide:nil

* Funktionale Programmierung

#+REVEAL_HTML: <img src="images/Paradiso_Canto_31.jpg" class="r-stretch">

* BLUME2000 2020 - Schulung "Funktionale Programmierung"

#+REVEAL_HTML: <img src="images/drracket.png" class="r-stretch">

* BLUME2000 2020 - Realität

#+REVEAL_HTML: <img src="images/kotlin-validation.png" class="r-stretch">

* Functional Programming in Kotlin?

- Lists / Option
- Validation
- Typystem

#+REVEAL_HTML: <img src="images/arrow.png" class="r-stretch">

* Hexagonale Architektur

#+REVEAL_HTML: <img src="images/hexagonal-architecture.png" class="r-stretch">

Source: [[https://commons.wikimedia.org/wiki/File:Hexagonal_Architecture.svg][Wikimedia Commons, CC-SA 4.0]]

* Profiling

#+begin_src kotlin
@SuppressWarnings("ThrowsCount", "LongMethod")
  fun updateWarenkorb(
    httpWarenkorbVeraenderung: HttpWarenkorbVeraenderung,
    sessionIdPayload: String,
  ): Warenkorb {
    val start = System.currentTimeMillis()

    val produkt = produktRepository.holeProduktViaProduktNummer(ProduktNummer(httpWarenkorbVeraenderung.produktNummer))
    ....

    val getProduktEnd = System.currentTimeMillis()
    logger.info { "get Produkt from DB took ${getProduktEnd - start}ms" }

    if (produkt == null) { ... }
    ...
    val warenkorbVeraenderungTransformationEnd = System.currentTimeMillis()
    logger.info { "transform into warenkorb-veränderung took ${warenkorbVeraenderungTransformationEnd - getProduktEnd}ms" }
    ...
    val warenkorbVeraenderungValidationEnd = System.currentTimeMillis()
    logger.info { "warenkorb-veraenderung validation took ${warenkorbVeraenderungValidationEnd - warenkorbVeraenderungTransformationEnd}ms" }
    ...
    val getWarenkorbEnd = System.currentTimeMillis()
    logger.info { "get Warenkorb from DB took ${getWarenkorbEnd - warenkorbVeraenderungValidationEnd}ms" }
    ...
}
#+end_src

* Monaden

#+REVEAL_HTML: <img src="images/programmierbares-semikolon.png" class="r-stretch">

[[https://funktionale-programmierung.de/2013/04/18/haskell-monaden.html][=https://funktionale-programmierung.de/2013/04/18/haskell-monaden.html=]]

* Monaden in Kotlin

#+begin_src kotlin
sealed interface ProductM<out A> {
  data class FindAllProducts<out A>(val cont: (Flow<Product>) -> ProductM<A>)
      : ProductM<A>

  data class FindProductById<out A>(val id: ProductId, val cont: (Option<Product>) -> ProductM<A>)
      : ProductM<A>

  data class CountProducts<out A>(val cont: (Long) -> ProductM<A>)
      : ProductM<A>

  data class CreateProduct<out A>(val product: Product, val cont: (Unit) -> ProductM<A>)
      : ProductM<A>

  data class Pure<out A>(val result: A) : ProductM<A>
}
#+end_src

* Monaden benutzen

#+begin_src kotlin
   CreateProduct(product1, {
   CreateProduct(product2, {
   FindAllProducts({ products ->
     ...
   })})})
#+end_src

* Kotlin ist nicht Java

#+begin_src kotlin
   CreateProduct(product1) {
   CreateProduct(product2) {
   FindAllProducts { products ->
     ...
   }}}
#+end_src

* Programmbausteine

#+begin_src kotlin
sealed interface ProductM<out A> {

  companion object {
    fun findAllProducts(): ProductM<Flow<Product>> =
	FindAllProducts(::Pure)
    fun findProductById(id: ProductId): ProductM<Option<Product>> =
	FindProductById(id, ::Pure)
    fun countProducts(): ProductM<Long> =
	CountProducts(::Pure)
    fun createProduct(product: Product): ProductM<Unit> =
	CreateProduct(product, ::Pure)
    fun <A> pure(result: A) = Pure(result)
  }

  fun <B> bind(next: (A) -> ProductM<B>): ProductM<B>
}
#+end_src

* Programmbausteine zusammensetzen

#+begin_src kotlin
   val c1 = createProduct(product1)
   val c2 = createProduct(product2)

   c1.bind {
   c2.bind {
   findAllProducts.bind { products ->
     ...
   }}}
#+end_src

* Vorher

#+begin_src kotlin
   CreateProduct(product1) {
   CreateProduct(product2) {
   FindAllProducts { products ->
     ...
   }}}
#+end_src

* Coroutinen und Continuations

#+begin_src kotlin
sealed interface ProductM<out A> {

  suspend fun susp(): A =
    suspendCoroutine { cocont: Continuation<A> ->
      val element = cocont.context[ProductCE]!! as ProductCE<A>
      element.productM = some(
        bind { result ->
          cocont.resume(result)
          element.productM.get()
        }
      )
    }
}
#+end_src

* Coroutinen und Continuations

#+begin_src kotlin
sealed interface ProductM<out A> {

  companion object {
   fun <A> productM(context0: CoroutineContext = EmptyCoroutineContext, block: suspend ProductMCoroutineDsl.() -> A): ProductM<A> {
      val element = ProductCE<A>(none())
      val context = context0 + element
      val coroutine: suspend () -> A = { ProductMCoroutineDsl().block() }
      coroutine.startCoroutine(
        Continuation(context) { result ->
          result.onFailure { exception ->
            val currentThread = Thread.currentThread()
            currentThread.uncaughtExceptionHandler.uncaughtException(currentThread, exception)
          }
        }
      )
      return element.productM.get()
    }
  }

  class ProductCE<A>(var productM: Option<ProductM<A>>) : AbstractCoroutineContextElement(ProductCE) {
    companion object Key : CoroutineContext.Key<ProductCE<*>>
  }
}
#+end_src

* Coroutine

#+begin_src kotlin
  productM {
    createproduct(product1).susp()
    createproduct(product2).susp()
    val products = findAllProducts().susp()
    ...
  }
#+end_src

* DSL

#+begin_src kotlin
class ProductMCoroutineDsl {
  suspend fun findAllProducts() =
      ProductM.findAllProducts().susp()
  suspend fun findProductById(id: ProductId) =
      ProductM.findProductById(id).susp()
  suspend fun countProducts() =
      ProductM.countProducts().susp()
  suspend fun createProduct(product: Product) =
      ProductM.createProduct(product).susp()

  suspend fun <A> pure(result: A): A = ProductM.pureM(result)
}
#+end_src

* DSL

#+begin_src kotlin
  productM {
    createproduct(product1)
    createproduct(product2)
    val products = findAllProducts()
    ...
  }
#+end_src

* Was ist mit dem Profiling?

FIXME: Bild mit "MOMENT MAL" oder so

* Endlich tut wer was!

#+begin_src kotlin
FIXME: function
class ProductMRunner(private val db: MutableMap<ProductId, Product>) {

  override tailrec suspend fun <A> run(productM: ProductM<A>): A =
    when (productM) {
      is FindAllProducts ->
        run(productM.cont(db.values.asFlow()))
      is FindProductById ->
        run(productM.cont(Option.fromNullable(db[productM.id])))
      is ProductM.CountProducts ->
        run(productM.cont(db.size.toLong()))
      is CreateProduct -> {
        db[productM.product.id] = productM.product
        run(productM.cont(Unit))
      }
      is Pure -> productM.result
    }
}
#+end_src

* Dependency Injection

#+begin_src kotlin
interface UnsafeProductMRunner {
  suspend fun <A> run(productM: ProductM<A>): A
}

class InMemoryProductM(private val db: MutableMap<ProductId, Product>)
  : UnsafeProductMRunner

final class MongoProductM(private val mongo: ReactiveFluentMongoOperations)
   : UnsafeProductMRunner
#+end_src

* Was ist mit dem Profiling?

#+begin_src kotlin
data class ProfilingRecord(val opSummary: String, val millis: Long)

class ProfilingRecorder(var records: MutableList<ProfilingRecord>) {
  suspend fun <A> run(summary: String, op: suspend () -> A): A {
    val start = System.currentTimeMillis()
    val result = op()
    val end = System.currentTimeMillis()
    records.add(ProfilingRecord(summary, end - start))
    return result
  }
}
#+end_src

* Profiling-Runner

#+begin_src kotlin
class InMemoryProductM(private val db: MutableMap<ProductId, Product>),
                       private val recorder: ProfilingRecorder)
  : UnsafeProductMRunner {

  override tailrec suspend fun <A> run(productM: ProductM<A>): A =
    when (productM) {
      is FindAllProducts ->
        run(productM.cont(recorder.run("findAllProducts()") { db.values.asFlow() } ))
      is FindProductById ->
        run(productM.cont(recorder.run("findProcuctById(" + productM.id.toString() + ")") {
          Option.fromNullable(db[productM.id])
        }))
      is CountProducts ->
        run(productM.cont(recorder.run("countProcucts()") { db.size.toLong() }))
      is CreateProduct -> {
        db[productM.product.id] = productM.product
        run(productM.cont(Unit))
      }
      is Pure -> productM.result
    }
}
#+end_src

* Separation of Concerns

#+begin_src kotlin
interface UnsafeProductMRunnerImplementation  {
  suspend fun findAllProducts(): Flow<Product>
  suspend fun findProductById(id: ProductId): Option<Product>
  suspend fun countProducts(): Long
  suspend fun createProduct(product: Product)
}

abstract class UnsafeProductMRunnerDecorator(private val delegate: UnsafeProductMRunnerImplementation)
    : UnsafeProductMRunnerImplementation {
  override suspend fun findAllProducts(): Flow<Product> = delegate.findAllProducts()
  override suspend fun findProductById(id: ProductId): Option<Product> = delegate.findProductById(id)
  override suspend fun countProducts(): Long = delegate.countProducts()
  override suspend fun createProduct(product: Product) = delegate.createProduct(product)
}
#+end_src

* Profiling-Decorator

#+begin_src kotlin
class ProfilingProductMDecoratorprivate(val delegate: UnsafeProductMRunnerImplementation,
                                        val recorder : ProfilingRecorder)
  : UnsafeProductMRunnerDecorator(delegate) {
  override suspend fun findAllProducts(): Flow<Product> =
    recorder.run("findAllProducts()") { super.findAllProducts() }

  override suspend fun findProductById(id: ProductId): Option<Product> =
    recorder.run("findProcuctById(" + id.toString() + ")") { super.findProductById(id) }

  override suspend fun countProducts(): Long =
    recorder.run("countProdcuts") { super.countProducts() }

  override suspend fun createProduct(product: Product) =
    recorder.run("createProduct(" + product.toString() + ")") { super.createProduct(product) }
}
#+end_src

* Decorator -> still not DDD style

???

* Spring

#+begin_src kotlin
@SpringBootApplication
class ExampleApplicationOne {
  @Bean
  fun outRunner(mongo: ReactiveFluentMongoOperations,
		@Value("\${spring.kafka.bootstrap-servers}") kafkaBootstrapServers: String)
      : UnsafeProductMRunner {
    val impl =
      KafkaProducerProductMDecorator(
        bootstrapAddress = kafkaBootstrapServers,
        delegate = KafkaConsumerProductMDecorator(
          bootstrapAddress = kafkaBootstrapServers,
          delegate = MongoProductMDecorator(mongo = mongo)
        )
      )
    return ImplementationProductMRunner(impl)
  }
  ...
}
#+end_src

* Purity of domain

- Spring
- Purity of domain
- ...

* TODOs

- link to code
- iSAQB meetup
  
