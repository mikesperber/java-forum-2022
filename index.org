#+title: Function Domain Driven Design with Kotlin
#+author: Michael Sperber & Benedikt Stemmildt
#+REVEAL_PLUGINS: (notes)
#+REVEAL_THEME: ./css/themes/active.css
#+REVEAL_HLEVEL: 100
#+REVEAL_TRANS: none
#+OPTIONS: toc:nil reveal-center:f H:4

* Funktionale Programmierung

#+ATTR_HTML: :height 380px;
[[file:images/Paradiso_Canto_31.jpg][file:images/Paradiso_Canto_31.jpg]]

* BLUME2000 2020 - Schulung "Funktionale Programmierung"

#+ATTR_HTML: :width 1000px;
[[file:images/drracket.png][file:images/drracket.png]]

* BLUME2000 2020 - Realität

#+ATTR_HTML: :width 1000px;
[[file:images/kotlin-validation.png][file:~/data/talks/java-forum-2022/images/kotlin-validation.png]]

* Post Mortem: How to do Functional Programming in Kotlin?

- Lists / Option
- Validation
- Typeystem

* Lists / Option

FIXME

* Validation

FIXME

* Typsystem

FIXME

* Arrow

#+ATTR_HTML: :height 380px;
[[file:images/arrow.png][file:images/arrow.png]]

* Hexagonale Architektur

#+ATTR_HTML: :height 380px;
[[file:images/hexagonal-architecture.png][file:images/hexagonal-architecture.png]]

Source: [[https://commons.wikimedia.org/wiki/File:Hexagonal_Architecture.svg][Wikimedia Commons, CC-SA 4.0]]

* Profiling

#+begin_src kotlin
@SuppressWarnings("ThrowsCount", "LongMethod")
  fun updateWarenkorb(
    httpWarenkorbVeraenderung: HttpWarenkorbVeraenderung,
    sessionIdPayload: String,
  ): Warenkorb {
    val start = System.currentTimeMillis()

    val produkt = produktRepository.holeProduktViaProduktNummer(ProduktNummer(httpWarenkorbVeraenderung.produktNummer))
    ....

    val getProduktEnd = System.currentTimeMillis()
    logger.info { "get Produkt from DB took ${getProduktEnd - start}ms" }

    if (produkt == null) { ... }
    ...
    val warenkorbVeraenderungTransformationEnd = System.currentTimeMillis()
    logger.info { "transform into warenkorb-veränderung took ${warenkorbVeraenderungTransformationEnd - getProduktEnd}ms" }
    ...
    val warenkorbVeraenderungValidationEnd = System.currentTimeMillis()
    logger.info { "warenkorb-veraenderung validation took ${warenkorbVeraenderungValidationEnd - warenkorbVeraenderungTransformationEnd}ms" }
    ...
    val getWarenkorbEnd = System.currentTimeMillis()
    logger.info { "get Warenkorb from DB took ${getWarenkorbEnd - warenkorbVeraenderungValidationEnd}ms" }
    ...
}
#+end_src

* Monaden

#+ATTR_HTML: :width 800px;
[[file:images/programmierbares-semikolon.png][file:images/programmierbares-semikolon.png]]

[[https://funktionale-programmierung.de/2013/04/18/haskell-monaden.html][=https://funktionale-programmierung.de/2013/04/18/haskell-monaden.html=]]

* Monaden in Kotlin

#+begin_src kotlin
sealed interface ProductM<out A> {
  data class FindAllProducts<out A>(val cont: (Flow<Product>) -> ProductM<A>) : ProductM<A>

  data class FindProductById<out A>(val id: ProductId, val cont: (Option<Product>) -> ProductM<A>) : ProductM<A>

  data class CountProducts<out A>(val cont: (Long) -> ProductM<A>) : ProductM<A>

  data class CreateProduct<out A>(val product: Product, val cont: (Unit) -> ProductM<A>) : ProductM<A>

  data class Pure<out A>(val result: A) : ProductM<A>
}
#+end_src

* Monaden benutzen

#+begin_src kotlin
   CreateProduct(product1, {
   CreateProduct(product2, {
   FindAllProducts({ products ->
     ...
   })})})
#+end_src

* Kotlin ist nicht Java

#+begin_src kotlin
   CreateProduct(product1) {
   CreateProduct(product2) {
   FindAllProducts { products ->
     ...
   }}}
#+end_src

* Programmbausteine

#+begin_src kotlin
sealed interface ProductM<out A> {

  companion object {
    fun findAllProducts(): ProductM<Flow<Product>> = FindAllProducts(::Pure)

    fun findProductById(id: ProductId): ProductM<Option<Product>> = FindProductById(id, ::Pure)

    fun countProducts(): ProductM<Long> = CountProducts(::Pure)

    fun createProduct(product: Product): ProductM<Unit> = CreateProduct(product, ::Pure)

    fun <A> pure(result: A) = Pure(result)
  }
}
#+end_src

* Programmbausteine zusammensetzen

#+begin_src kotlin
   createproduct(product1).bind {
   createproduct(product2).bind {
   findAllProducts.bind { products ->
     ...
   }}}
#+end_src

* Vorher

#+begin_src kotlin
   CreateProduct(product1) {
   CreateProduct(product2) {
   FindAllProducts { products ->
     ...
   }}}
#+end_src

* Coroutinen und Continuations

#+begin_src kotlin
sealed interface ProductM<out A> {

  suspend fun susp(): A =
    suspendCoroutine { cocont: Continuation<A> ->
      val element = cocont.context[ProductCE]!! as ProductCE<A>
      element.productM = some(
        bind { result ->
          cocont.resume(result)
          element.productM.get()
        }
      )
    }
}
#+end_src

* Coroutinen und Continuations

#+begin_src kotlin
sealed interface ProductM<out A> {

  companion object {
   fun <A> productM(context0: CoroutineContext = EmptyCoroutineContext, block: suspend ProductMCoroutineDsl.() -> A): ProductM<A> {
      val element = ProductCE<A>(none())
      val context = context0 + element
      val coroutine: suspend () -> A = { ProductMCoroutineDsl().block() }
      coroutine.startCoroutine(
        Continuation(context) { result ->
          result.onFailure { exception ->
            val currentThread = Thread.currentThread()
            currentThread.uncaughtExceptionHandler.uncaughtException(currentThread, exception)
          }
        }
      )
      return element.productM.get()
    }
  }

  class ProductCE<A>(var productM: Option<ProductM<A>>) : AbstractCoroutineContextElement(ProductCE) {
    companion object Key : CoroutineContext.Key<ProductCE<*>>
  }
}
#+end_src

* Coroutine

#+begin_src kotlin
  productM {
    createproduct(product1).susp()
    createproduct(product2).susp()
    val products = findAllProducts().susp()
    ...
  }
#+end_src

* DSL

#+begin_src kotlin
class ProductMCoroutineDsl {
  suspend fun findAllProducts() = ProductM.findAllProducts().susp()
  suspend fun findProductById(id: ProductId) = ProductM.findProductById(id).susp()

  suspend fun countProducts() = ProductM.countProducts().susp()

  suspend fun createProduct(product: Product) = ProductM.createProduct(product).susp()

  suspend fun productsSaved() = ProductM.productsSaved().susp()

  suspend fun <A> pure(result: A): A = ProductM.pureM(result)
}
#+end_src

* DSL

#+begin_src kotlin
  productM {
    createproduct(product1)
    createproduct(product2)
    val products = findAllProducts()
    ...
  }
#+end_src

* Was ist mit dem Profiling?

FIXME: Bild mit "MOMENT MAL" oder so

* Endlich tut wer was!

#+begin_src kotlin
class ProductMRunner(private val db: MutableMap<ProductId, Product>) {

  override tailrec suspend fun <A> run(productM: ProductM<A>): A =
    when (productM) {
      is FindAllProducts ->
        run(productM.cont(db.values.asFlow()))
      is FindProductById ->
        run(productM.cont(Option.fromNullable(db[productM.id])))
      is ProductM.CountProducts ->
        run(productM.cont(db.size.toLong()))
      is CreateProduct -> {
        db[productM.product.id] = productM.product
        run(productM.cont(Unit))
      }
      is Pure -> productM.result
    }
}
#+end_src

* Dependency Injection

#+begin_src kotlin
interface UnsafeProductMRunner {
  suspend fun <A> run(productM: ProductM<A>): A
}

class InMemoryProductM(private val db: MutableMap<ProductId, Product>)
  : UnsafeProductMRunner

final class MongoProductM(private val mongo: ReactiveFluentMongoOperations)
   : UnsafeProductMRunner
#+end_src

* Was ist mit dem Profiling?

#+begin_src kotlin
// FIXME: annotated InMemoryProductM
#+end_src

* Separation of Concerns

#+begin_src kotlin
interface UnsafeProductMRunnerImplementation  {
  suspend fun findAllProducts(): Flow<Product>
  suspend fun findProductById(id: ProductId): Option<Product>
  suspend fun countProducts(): Long
  suspend fun createProduct(product: Product)
}

abstract class UnsafeProductMRunnerDecorator(private val delegate: UnsafeProductMRunnerImplementation) : UnsafeProductMRunnerImplementation {
  override suspend fun findAllProducts(): Flow<Product> = delegate.findAllProducts()
  override suspend fun findProductById(id: ProductId): Option<Product> = delegate.findProductById(id)
  override suspend fun countProducts(): Long = delegate.countProducts()
  override suspend fun createProduct(product: Product) = delegate.createProduct(product)
}
#+end_src

* Profiling-Decorator

#+begin_src kotlin
data class ProfilingRecord(val opSummary: String, val millis: Long)

class ProfilingRecorder(var records: MutableList<ProfilingRecord>) {
  suspend fun <A> run(summary: String, op: suspend () -> A): A {
    val start = System.currentTimeMillis()
    val result = op()
    val end = System.currentTimeMillis()
    records.add(ProfilingRecord(summary, end - start))
    result
  }
}
#+end_src

* Profiling-Decorator

#+begin_src kotlin
class ProfilingProductMDecoratorprivate(val delegate: UnsafeProductMRunnerImplementation,
                                        val recorder : ProfilingRecorder)
  : UnsafeProductMRunnerDecorator(delegate) {
  override suspend fun findAllProducts(): Flow<Product> =
    recorder.run("findAllProducts()") { super.findAllProducts() }

  override suspend fun findProductById(id: ProductId): Option<Product> =
    recorder.run("findProcuctById(" + id.toString() + ")") { super.findProductById(id) }

  override suspend fun countProducts(): Long =
    recorder.run("countProdcuts") { super.countProducts() }

  override suspend fun createProduct(product: Product) {
    recorder.run("createProduct(" + product.toString() + ")") { super.createProduct(product) }
  }
}
#+end_src
* Decorator -> still not DDD style

#+begin_src kotlin
interface UnsafeProductMRunnerImplementation  {
  suspend fun findAllProducts(): Flow<Product>
  suspend fun findProductById(id: ProductId): Option<Product>
  suspend fun countProducts(): Long
  suspend fun createProduct(product: Product)

  suspend fun productsSaved(): Flow<Product>
}
#+end_src

* Move stuff around -> Nice.

#+begin_src kotlin
interface UnsafeProductMRunnerImplementation  {
  suspend fun findAllProducts(): Flow<Product>
  suspend fun findProductById(id: ProductId): Option<Product>
  suspend fun countProducts(): Long
  suspend fun createProduct(product: Product)

  suspend fun productsSaved(): Flow<Product>
}
#+end_src

* Spring

#+begin_src kotlin
@SpringBootApplication
class ExampleApplicationOne {
  @Bean
  fun runner(mongo: ReactiveFluentMongoOperations,
	     @Value kafkaBootstrapServers: String): UnsafeProductMRunner =
    ImplementationProductMRunner(MongoProductMDecorator(mongo = mongo))
}
#+end_src

* Purity of domain

- Spring
- Purity of domain
- ...

* TODOs

- link to code
- iSAQB meetup
  
